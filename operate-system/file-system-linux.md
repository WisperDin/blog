# 从Linux学习文件系统原理

## 前言

从问题出发，在使用Linux的过程中，有时会因对Linux一切皆文件的原则不太了解，在开发，运维的时候遇到一些奇奇怪怪的问题，所以我打算总结，学习一下Linux下文件系统的各种原理知识。



## 看完这篇文章你可能会解决的问题

1. Linux/Windows双系统中，为什么Windows的卷Linux下可以访问，而Linux的卷Windows不能访问？
2. Linux中的挂载mount到底是什么意思？
3. 超级块，inode，dentry 是什么东西？
4. 软连接 硬链接 区别 ？
5. **终极问题：** Linux下打开一个文件的底层大概是怎么实现的？




## 概念大纲

- 文件 (File)

- Linux树型目录结构

- 文件的逻辑结构

- 文件存取方法 (File Access)

- 文件的物理结构

- **文件系统（File System）**

  - 文件块
  - 常见的文件系统
  - 文件挂载
  - Linux的VFS
  - ext2文件系统
  - **LInux打开一个文件，读取这个文件的底层实现**

- 软链接硬链接

- 磁盘存储空间管理

- *文件存取控制/分级安全*

- *网络文件系统*

  ​




## 具体概念

### 文件

文件是进程创建的信息逻辑单元，可被多个进程并发使用物理上一般存储在磁盘块中，文件由操作系统统一管理，而处理文件的这一部分称为文件系统（File System）

> 在 UNIX 系统中，操作系统为磁盘上的文本与图像、鼠标与键盘等输入设备及网络交互等 I/O 操作设计了一组通用 API，使他们被处理时均可统一使用字节流方式。换言之，UNIX 系统中除进程之外的一切皆是文件，而 Linux 保持了这一特性

>  文件在结构上其实可以有字节序列，记录序列，树型结构等，为了追求灵活，UNIX/Linux/Windows 均采用了字节序列来对待文件

在UNIX/Linux 中 文件分类如下：

- 普通文件

一般分为ASCII文件或者二进制文件

- 目录文件

管理文件系统结构的系统文件

- 特殊文件（设备文件）

UNIX把所有I/O设备当做特殊文件，对I/O设备的操作模仿为对普通文件的存取，通过这个方法统一文件，设备



注意：很多资料说文件分类包括 *符号链接文件*  ，但其实不应该包括，因为符号链接文件其实本质上是普通文件

符号链接文件：一条指向其他文件或目录的引用，一般也称软连接



### Linux树型目录结构

严格来说，Linux在目录管理中采用了带链接的树型目录结构

在Linux下的ext2文件系统创建一个目录时，ext2会分配一个inode与至少一个block给该目录，

- inode记录母的的相关权限，树型，记录分配到的block号；
- block 记录在这个目录下的文件名与该文件名占用的inode号数据，所以目录所占的block内容如下：

![ç®å½å ç¨ç block è®°å½çæ°æ®ç¤ºæå¾](http://cn.linux.vbird.org/linux_basic/0230filesystem_files/dir_block.jpg)

在Linux中，文件目录项的内容为：

- 文件inode号
- 文件名

所以，在Linux中，一个文件的文件名其实时存在文件所在目录文件的block里的，文件本身的inode和block都没有存自己的文件名



**文件创建**

当在目录下创建文件时，ext2会分配一个inode与相对于该文件大小的block数量给该文件



**目录树读取**

假设要读取一个 /etc/passwd 这个文件，步骤如下：

1. 从挂载点的信息找到 根目录 inode号，且有r,x权限，可以读取该block内容
2. 在上一步根目录 / 的block中，找到文件名为 etc 的目录项 的inode 号
3. 读取etc的inode号的inode，得知当前操作者具有r,x权限，于是可以读取 etc 的block
4. 在上一步 etc目录 的block中，找到文件名为 passwd 的目录项 的inode 号
5. 读取passwd的inode号的inode，得知当前操作者具有r权限，于是可以读取 passwd的block





### 文件的逻辑结构

- 字节序列

文件内部不再划分记录，为一组相关信息组成的有序字节流，即流式文件。

**WINDOWS/UNIX/Linux使用这种文件模型**

- 记录序列

一组连续记录的集合

- 树



### 文件的存取方法

- 顺序存取

进程在系统中可以从头按序读取文件的全部字节，但不同跳过，不能不按序  

存储介质时磁带的时，就比较方便

- 随机访问

可以不按顺序地读取文件中的字节

**UNIX、Linux和Windows等操作系统都采用顺序存取和随机存取两种方法。**



### 文件的物理结构



**连续分配**

每个文件作为一连串**连续**数据块存储在磁盘上，在块大小为1KB的磁盘上，50KB的文件就要分配50个连续的块

优点：

1. 实现简单，只要知道文件起始块和块数就可以找到文件占用的所有物理块
2. 读操作较快

缺点：

1. 在一段时间使用后，磁盘空间零散，产生外部碎片
2. 文件创建时必需指定文件的最终大小



**链表分配**

每个块的第一个字节作为指向下一块的指针，块的其他地方存数据

优点：

1. 充分利用每个物理块，只有最后一个物理块有内部碎片
2. 目录项中只需要存放第一块的磁盘地址

缺点：

1. 顺序访问方便但是随机访问相当缓慢，要读取中间第n个块要将前面的n-1个块读取出来才可以
2. 指针占了一些字节，每次磁盘存储数据的字节不再是2的整数幂，降低系统的运行效率




**采用内存中的表进行链表分配**

对于链表分配方法，可以将每个磁盘块的指针拿到内存中保存下来，保存到的表称为**文件分配表FAT**

由于这个表在内存中，所以当随机访问时链式查找这个表消耗也不高

优点：拥有链表分配方法的优点，并且克服了随机访问性能较差的缺点

缺点：视磁盘空间的大小，FAT占用的内存空间可能会很大

比如1TB硬盘，1KB大小的块，块数就有1TB/1KB = 1G =2^30  约等于 10亿个物理块

假设每项需要3个字节存储，那么这个FAT就要占用3GB的内存



windows系统使用得较为多的FAT文件系统就是采用了这种方法组织文件的物理结构



**inode索引**

定义inode这个数据结构，存储文件的一些属性和对应文件块的磁盘地址，只有当文件打开时，inode才会在内存中

优点：

inode 在内存中保存的数组的大小正比于同时打开的文最大文件数，而FAT方式的表时正比与磁盘自身的大小，所以inode索引占用的内存空间会小很多

缺点：

当一个文件所含物理块超过inode结构能容纳的数目时怎么办？ （解决方案--其实就是多重索引技术，指向文件块的磁盘地址可指向到一些索引块，增加寻址空间）



windows的NTFS采用了类似的方法，linux的ext2文件系统使用了多重索引技术

![âå¾4-13 ièç¹çä¾å­âçå¾çæç´¢ç»æ](http://7xlcir.com1.z0.glb.clouddn.com/index-node.png)

> 外部碎片：还没有被分配出去（不属于任何进程），但由于太小了无法分配给申请内存空间的新进程的内存空闲区域。
>
> （是由于大量信息由于先后写入、置换、删除而形成的空间碎片）

> 内部碎片：已经被分配出去（能明确指出属于哪个进程）却不能被利用的内存空间
>
> （存量信息容量与最小存储空间单位不完全相符而造成的空间碎片）





### 文件系统

由问题引入，

> 在电脑上安装了Windows与Linux的双系统后，觉得很奇怪的一件事，Linux下能挂载并访问Windows的文件卷，而Windows只能查看自己的，为什么？



文件系统存放在磁盘中，磁盘可被划分为一个或多个分区，每个磁盘的0号分区称为MBR （Matster  Boot Record）用来引导计算机

> *在老式的操作系统中 计算机被引导时 首先确定活动分区，读入分区引导块，并且执行，引导块中的程序将装载分区中的操作系统，现在一般采用grub管理启动菜单*



**文件块 (block)**

对于VFS与具体的文件系统来说，block时最基本的数据传输单元，当内核需要访问文件数据时，它首先从磁盘上读取一个块，但对于实际的磁盘来说，扇区时最小的可寻址单元，块设备无法对比它还小的单元进行寻址，操作。

所以块一般是整数倍的扇区大小，即一个块对应磁盘上的一个或多个扇区，一般为2的整数倍个

> 文件系统以block作为读写单元使得读写性能大大提升，但也造成了空间浪费，不过在磁盘容量廉价，追求性能的时代，这个是可以接受的





**文件挂载(mount)**

挂载（mount） 在Linux的定义为将一个文件系统与一个物理存储设备关联起来，进行挂载时，需要提供文件系统类型，文件系统和一个挂载点



**文件系统的分类**

- MS-DOS文件系统，FAT以及其扩展FAT32 -- DOS、WIN95、 WIN VISTA等系统支持
- NTFS WINDOWS 较为现代的文件系统
- ext 文件系统 linux普遍采用的文件系统 有ext2 ext4 等扩展


- CD-ROM 文件系统



**FAT VS EXT 访问文件物理块的大体区别**

FAT文件系统访问文件物理块一般通过读取文件目录表项中第一块个文件物理块的编号，通过查找内存中的FAT（文件分配表），链式查找出所有的物理块

![âMS-DOS ç®å½é¡¹âçå¾çæç´¢ç»æ](http://210.34.136.253:8488/czxtjx/images/Fig4_16.gif)

EXT 则通过多级目录访问到文件目录项中的inode号，再从inode索引查找到所有此文件的物理块

![âUNIX ç®å½é¡¹âçå¾çæç´¢ç»æ](http://210.34.136.253:8488/czxtjx/images/Fig4_17.gif)

![inode/block æ°æ®å­åç¤ºæå¾](http://cn.linux.vbird.org/linux_basic/0230filesystem_files/filesystem-1.jpg)

*目录项：每个目录下的文件控制块*

*目录：目录项的有序集合*



**Linux引入虚拟文件系统VFS**

> 相比于Windows通过不同的盘符来区分不同文件系统发起的请求，所以不需要将不同的文件系统整合为统一的模式

Linux 在处理众多文件系统的差异时，将各种具有不同差异的文件系统整合到一个统一的结构中，例如：一个LInux系统 可以用ext2作为根文件系统，ext3 挂载在 /usr CD-ROM挂载在 /mnt 从而使得这些不相容的文件系统对用户，进程是相同的

所以通过VFS这层抽象，不同的文件系统都能通过统一的文件访问方式访问，read,open 等文件方面系统调用方法可以操作不同的文件系统

![å¾ 1. Linux æä»¶ç³»ç»ç»ä»¶çä½ç³»ç»æ](https://www.ibm.com/developerworks/cn/linux/l-linux-filesystem/figure1.gif)

Linux 文件系统分类

- 网络文件系统，如 nfs、cifs 等；
- 磁盘文件系统，如 ext4、ext3 等；
- 特殊文件系统，如 proc、sysfs、ramfs、tmpfs 等。



问题：那对于各种具有差异的文件系统，VFS是怎么进行抽象的呢？

Linux 以一组通用对象的角度看待所有文件系统 ：

- **超级块 superblock**

超级块在每个文件系统的根上，描述和维护文件系统的状态

包括inode/block 总量，使用量，剩余量，文件系统格式等相关信息

- **inode (索引节点)**

文件系统中管理的每个对象（文件或目录）在Linux中表示为一个inode。

inode包含管理文件系统中对象所需的元数据（metadata）（记录文件大小，权限，创建时间，所有者等信息）

一个文件占用一个inode，inode唯一标识一个文件 通过inode可以查找到此文件的block号

- **dentry （目录项）**

实现文件名与inode的映射，有一个缓存来保存最近使用的dentry

- **File** 

与一个进程相关联打开的文件



> 如设备文件 event5 在路径 /dev/input/event5 中，其存在四个目录项对象：
>
> - / 
>
> - dev/ 
>
> - input/ 
>
> - event5
>
>   文件对象代表由进程打开的文件。这四个对象与进程及磁盘文件间的关系如图 ，其中 d_inode 即为硬链接。为文件路径的快速解析，Linux VFS 设计了目录项缓存（Directory Entry Cache，即 dcache）。
>
> ![å¾ 4. VFS çå¯¹è±¡ä¹é´çå¤ç](https://www.ibm.com/developerworks/cn/linux/l-cn-hardandsymb-links/image004.jpg)



### ext2文件系统

整体展示图：

![âLinux ext2æä»¶ç³»ç»çç£çå¸å±âçå¾çæç´¢ç»æ](https://ask.qcloudimg.com/http-save/yehe-1147827/yh0btq9nlt.png?imageView2/0/w/1620)

EXT2 所支持的块大小为 **1K，2K 及 4K** 。



- Boot Block 引导块

EXT2 的头 1024 Bytes 称为 Boot Block，引导块，预留给 VBR，即分区的引导扇区，不受 EXT2 文件系统的管理。

- Block Group

其余空间被划分为多个块，称块组，任何我给定文件的数据通常尽可能在一个块组中

每个块组包含：

- Super Block超级块 1个块
- GDT 块组描述表 N个块
- Block Bitmap 块位图 1个块
- Inode 位图 1个块
- Inode 表 一个块
- Data Block 数据块 N个块





**超级块**

Superblock 是记录整个 filesystem 相关信息的地方， 没有 Superblock ，就没有这个 filesystem 了。他记录的信息主要有：

- block 与 inode 的总量；
- 未使用与已使用的 inode / block 数量；
- block 与 inode 的大小 (block 为 1, 2, 4K，inode 为 128 bytes)；
- filesystem 的挂载时间、最近一次写入数据的时间、最近一次检验磁盘 (fsck) 的时间等文件系统的相关信息；
- 一个 valid bit 数值，若此文件系统已被挂载，则 valid bit 为 0 ，若未被挂载，则 valid bit 为 1 。


注：按道理超级块每个文件系统只需要一个，但是其实超级块在每个 Block Group 都会保存一份，作为备份存在

![img](http://blog.51cto.com/attachment/201103/151042688.jpg)

**块组描述符表**

Group Descriptor Table

这张表包含了 **整个系统所有块组的信息**，由一个接一个的块组描述符组成。每个块组都包含这张表的复本，紧跟超级块，作用也一样，用于修复系统。

正常工作时 EXT2 只使用第一个复本，即块组0 中的。

包含：

该块组的块位图、Inode 位图、Inode 表的位置，可用块数量，可用 Inode 数量，已用目录数量。

![img](http://blog.51cto.com/attachment/201103/151159109.jpg)

**块位图**

Block Bitmap

该块组中块的分配位图，每一位代表一个块的当前状态，1 为已用，0 为可用。据此位图来分配或回收块。



**inode 位图**

inode Bitmap

与块位图类似，每个bit表示一个inode是否空闲可用



**inode表**

inode表时当前块组所有inode的集合，用于追踪块组中所有文件的元数据

（内核数据结构，存放了所有文件的inode **所有当前打开的文件和目录的inode将会从磁盘这个位置装入内存中**）

该表会被操作系统频繁访问

> 每个Inode的结构如下
>
> ![img](http://blog.51cto.com/attachment/201103/151343645.jpg)



**数据区块 data block**

data block 是用来放置文件内容数据地方，在 Ext2 文件系统中所支持的 block 大小有 1K, 2K 及 4K 三种而已。



### Linux打开一个文件，读取这个文件的底层实现

例如，要通过绝对路径名打开一个文件，如 open  /usr/ast/file 

1. 系统从挂载点信息定位根目录，根目录通常使用 2号 inode ，目录缓存 directory cache 存放一条 根目录对应的inode节点号的记录
2.  在根目录 2号inode节点所指向的block中，查找文件名为 usr 的目录项，找到这个目录项的 inode号，这就是/usr 目录的inode号，类似地，写入目录缓存
3. 通过类似操作，直至在目录 /usr/ast 的block里面，找到文件名为file的文件对应的inode号，
4. 如果文件存在（找到 /usr/ast 目录下的 file文件的inode号），在当前**磁盘**（假定ext2文件系统）中的 **inode表**中，以inode为索引查找对应的inode，**将该inode装入内存中** ，再inode内的物理块索引指针，找到此文件的所有物理块



### 软链接 VS 硬链接

在Linux上，文件被分为两部分

- 用户数据 User Data

文件数据块 data block（文件存放的物理块）

- 元数据 metadata

文件的附加属性，如文件大小，创建时间，所有者等信息，而元数据中的 **inode** 号，作为文件的唯一标识存在，系统通过 **inode** 号找到文件正确的文件数据块(data block)



要理解这个，先要理解正常一个文件打开的流程(程序通过文件名获取文件内容)

![å¾ 1. éè¿æä»¶åæå¼æä»¶](https://www.ibm.com/developerworks/cn/linux/l-cn-hardandsymb-links/image001.jpg)



**硬链接** 

为解决文件的共享问题，Linux 引入两种链接：

- 硬链接 （hard link）
- 软连接 （符号链接 symbolic link）

好处：

- 文件更好共享
- 隐藏文件路径
- 增加权限安全
- 节省存储

若一个 inode 对应多个文件名，则称这些文件为**硬链接** 换言之，硬链接就是同一文件使用了多个文件名（别名）

![å¾ 2. è½¯é¾æ¥çè®¿é®](https://www.ibm.com/developerworks/cn/linux/l-cn-hardandsymb-links/image002.jpg)

此处hard link 就是file的别名

Linux下创建硬链接 link/ln

```sh
link oldfile newfile 
ln oldfile newfile
```



总结特性：

- 文件有相同的inode,data block；
- 只能对已存在的文件进行创建；
- 不能交叉文件系统进行硬链接的创建；
- 不能对目录进行创建，只可对文件创建；
- 删除一个硬链接文件并不影响其他有相同 inode 号的文件。

**软链接**

若文件用户数据块 data block 存放的内容时另一文件的**路径名**的指向 则该文件就是软链接，所以软链接本质上是一个普通文件，只是存放的数据指向着一个文件路径名

特性：

- 软链接有自己的文件属性及权限等；
- 可对不存在的文件或目录创建软链接；
- 软链接可交叉文件系统；
- 软链接可对文件或目录创建；
- 创建软链接时，链接计数 i_nlink 不会增加；
- 删除软链接并不影响被指向的文件，但若被指向的原文件被删除，则相关软连接被称为死链接（即 dangling link，若被指向路径文件被重新创建，死链接可恢复为正常的软链接）。

![å¾ 2. è½¯é¾æ¥çè®¿é®](https://www.ibm.com/developerworks/cn/linux/l-cn-hardandsymb-links/image002.jpg)



### 磁盘存储空间管理

一般常用的文件存储空间管理方法有：

- 空闲表法

记录磁盘那些盘块为空，需要建立一张空闲空间表

![âç©ºé²è¡¨æ³âçå¾çæç´¢ç»æ](https://upload-images.jianshu.io/upload_images/5853159-0e4943cc3dafc6ec.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/326)

优点：适合存放连续 文件

缺点：

1. 存储空间如果有大量空闲区时，空闲表非常大，检索效率降低
2. 使用一段时间后会产生外部碎片



- 空闲块链接法

用链接的方法链接空闲块

优点：管理信息不用额外保存，只需要一个内存单元保留链头

缺点：链上增加，移走空闲块I/O消耗大，破坏物理块存放数据大小为2的幂次



- **位示图法 Bit Map**

用一串二进制其中每一位表示一个物理块的空闲情况



- **空闲块成组链接**

UNIX S V操作系统采用成组链接法管理磁盘空闲块

//TODO

![âç©ºé²åæç»é¾æ¥æ³âçå¾çæç´¢ç»æ](http://slidesplayer.com/11113366/59/images/48/UNIX%E7%B3%BB%E7%BB%9F%E9%87%87%E7%94%A8%E4%BA%86%E8%BF%99%E7%A7%8D%E6%88%90%E7%BB%84%E7%A9%BA%E9%97%B2%E5%9D%97%E9%93%BE%E8%A1%A8%E7%AE%A1%E7%90%86%E6%96%B9%E6%B3%95%E3%80%82.jpg)

如上图，在块号栈中，S.free 表示栈深 S.free 下一位 0索引位表示栈底

**分配空间：**

​	分配物理块时，先做栈深 - 1 表示需要分配一个物理块，然后以 减一后的栈深作为索引 访问块号栈，如图，设一开始栈深100，-1后访问 99索引所在的单元，得到盘块号201 这就是要分配出去的空闲块

​	如果当前栈深为1，需要分配两个空闲盘块时，先栈深-1，系统特殊处理，以0为索引下标，读出组长块（下一个空闲索引块，如图是盘块号为300的物理块）的盘号，把找到的下一个索引块的栈深，空闲块号栈覆盖到原来的块号栈中，再把刚刚该索引块分配出去（就是刚300号的物理块），接着按正常方法分配一个物理块。

**释放空间：**

​	释放物理块时，先做栈深+1 然后以+1后的栈深作为索引，将释放回来的物理块号覆盖到那个位置

​	如果栈深已满，还需要释放物理块，则先将该栈的内容写到释放回来的新盘块中，将栈深，空闲块号栈清0，以0为索引，将新盘块号写到相应的单元中，栈深+1

优点：

分配回收方便，不需专用块来存放分配表





### 引用

> 理解 Linux 的硬链接与软链接 https://www.ibm.com/developerworks/cn/linux/l-cn-hardandsymb-links/index.html
>
> Linux 文件系统剖析 https://www.ibm.com/developerworks/cn/linux/l-linux-filesystem/
>
> 鸟哥的Linux私房菜 第八章 Linux磁盘与文件系统管理  http://cn.linux.vbird.org/linux_basic/0230filesystem_1.php
>
> 磁盘I/O那些事 https://tech.meituan.com/about-desk-io.html
>
> 现代操作系统 第四章 文件系统 第十章 第五节 Linux 文件系统
>
> Linux基础：文件系统 http://wuchong.me/blog/2014/07/19/linux-file-system/#comments
>
> 深入理解操作系统原理之文件系统 
> https://blog.csdn.net/xiaokang123456kao/article/details/74171875
>
> Linux 的文件与目录
> https://www.ibm.com/developerworks/cn/linux/l-cn-hardandsymb-links/index.html
>
> ext2文件系统解构探析  http://blog.51cto.com/molinux/505485

