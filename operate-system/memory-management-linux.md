## 基于Linux学习内存管理

## 前言



## 重点题目

分段，分页 逻辑地址转物理地址

页面置换

分区



## 大纲

- 地址空间 （存储器抽象）
- 重定位
- 分区
- **分页，分段**
- **段页式系统**
- 虚拟内存
  - 请求分页
  - 缺页中断
- 内存抖动
- Linux下的内存管理



## 联系编程

垃圾回收



## 细讲

### 地址空间

直接暴露物理内存给进程，主要有两个问题

1. 进程可以寻址内存的每个字节，有可能会破坏操作系统的正常运行
2. 多个进程同时运行时，进程操作同一片物理内存时可能会出现问题

地址空间是一种对物理内存的一种抽象，使得多个进程同时存在在内存中并且不互相影响，地址空间是对进程抽象的内存，每个进程都有自己的地址空间，并且不同进程的地址空间相互独立

地址空间仅仅是对进程做了一层物理内存的抽象，使得进程使用内存不用考虑复杂的问题，进程实质上使用的还是物理内存

所以引入重定位技术，以实现地址空间到物理空间的映射



### 重定位

根据映射的时机，重定位可分为：

- 静态重定位

**目标程序装入内存时**，由装入程序改写程序中指令和数据的地址，在程序运行期间不再进行重定位

（程序静态链接）

优点：不需要额外的硬件地址转换机构

缺点：

1. 程序的存储空间只能是连续的一片
2. 重定向后空间不可移动

- 动态重定位

**程序执行期间**，每次访问内存前都进行重定位，依赖地址转换机构

优点：

1. 程序占用的内存空间动态可变
2. 目标程序装入内存时无需任何修改



### 分区法

除操作系统占用内存低址外，其余内存分配给用户进程，划分若干分区，每个分区容纳一个分区，按分区划分方法，有：

- 固定分区法

使用一个分区说明表记录每个划分的分区的大小，基址，使用情况

- 动态分区法

各个分区时在相应进程进入内存时才建立的，使其大小适应进程大小

常用的数据结构：

1. 空闲分区表 -- 表项：分区号，分区大小，起始地址，分区状态
2. 空闲分区链 将所有空闲分区链接成一条链

分配算法：

- 最先适应算法 First Fit

空闲表按位置排序，地址越小序号越小

优点：为大进程预留高地址的空闲空间

缺点：高地址，低地址利用不均匀

- 最佳适应算法 Best Fit

空闲表按空闲块大小升序排序

在满足进程要求前提下，尽量分配最小的空闲块

- 循环适应算法 Next Fit

每次找到合适的空闲块时，记下位置，下次查找空闲块直接从这里往下查找

- 最坏适应算法 Worst Fit

最佳分配算法的反向



分区的

优点：需要的硬件支持很少，易实现

缺点：碎片严重，内存利用率低，作业大小受内存限制



### 分页法



### 分段法



